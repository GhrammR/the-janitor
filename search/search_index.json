{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Janitor","text":"<p>v5.4.0-GOLD \u2014 Rust-Native. Zero-Copy. Link-Time Excision.</p> <p>\"Code is Liability. Sovereignty is Metabolic.\"</p>"},{"location":"#i-the-diagnosis-metabolic-bloat","title":"I. THE DIAGNOSIS: METABOLIC BLOAT","text":"<p>Every codebase accumulates dead weight. Functions that were called once, classes that were subclassed by a deleted module, utilities from a refactoring that never shipped. Traditional linters flag style violations. They do not detect entropy.</p> <p>The consequence is Metabolic Bloat: dead symbols that occupy binary space, extend build times, inflate cognitive load, and survive code review because no tool has the reference resolution to prove they are unreachable.</p>"},{"location":"#ii-the-cure-the-sovereign-stack","title":"II. THE CURE: THE SOVEREIGN STACK","text":"<p>The Janitor is not a linter. It is a fiduciary agent.</p>"},{"location":"#the-anatomist","title":"The Anatomist","text":"<p>Parses Python source via Tree-sitter CST. Extracts every <code>def</code>, <code>class</code>, and top-level symbol as a zero-copy <code>Entity</code> with byte ranges, qualified names, decorator lists, and structural hashes. Builds a directed reference graph resolving imports, attribute calls, and <code>__all__</code> exports.</p>"},{"location":"#the-6-stage-dead-symbol-pipeline","title":"The 6-Stage Dead Symbol Pipeline","text":"Stage Filter Guard 0 Directory exclusion (<code>tests/</code>, <code>migrations/</code>, <code>venv/</code>) <code>Protection::Directory</code> 1 Reference graph: in-degree &gt; 0 <code>Protection::Referenced</code> 2+4 Heuristic wisdom + <code>__all__</code> exports Various 3 Library mode: all public symbols <code>Protection::LibraryMode</code> 5 Aho-Corasick scan of non-<code>.py</code> files <code>Protection::GrepShield</code> <p>Anything that survives all five gates is a confirmed dead symbol.</p>"},{"location":"#the-reaper","title":"The Reaper","text":"<p>Executes surgical byte-range deletion. Sorts targets descending by <code>start_byte</code> (bottom-to-top splice) to preserve upstream offsets. UTF-8 hardened via <code>str::is_char_boundary()</code>. Atomic backup to <code>.janitor/ghost/</code> before first write.</p>"},{"location":"#the-forge","title":"The Forge","text":"<p>Alpha-normalized BLAKE3 structural hashing detects duplicate functions with identical logic but different names. Injects Safe Proxy Pattern: duplicate bodies become one-line wrappers delegating to a shared canonical implementation.</p>"},{"location":"#the-shadow","title":"The Shadow","text":"<p>Symlink-based overlay of the source tree. Before any physical deletion, symlinks for dead-symbol files are unmapped and <code>pytest</code> is run in the shadow tree. Physical deletion proceeds only on a passing test suite; symlinks are restored on failure.</p>"},{"location":"#iii-the-economics-utility-pricing","title":"III. THE ECONOMICS: UTILITY PRICING","text":"<p>The Audit is Free. The Purge is Paid.</p> Tier Cost Scope Bounty Hunter $49/yr Individual. Pay-as-you-purge ($1.00/MB deleted). Sovereign Squad $499/yr Team (5 users). Shared PoUD credit pool. Fiduciary Core Custom Enterprise (&gt;10M LOC). Priority support. <p>Anti-gaming constraint: code must be &gt;90 days old. Purging symbols created within 90 days incurs a 5\u00d7 tax and generates zero credits.</p> <p>Purchase a Token \u2192 thejanitor.app</p>"},{"location":"#iv-installation","title":"IV. INSTALLATION","text":""},{"location":"#from-source-recommended","title":"From Source (Recommended)","text":"<p>Requires: Rust 1.82+, <code>just</code>.</p> <pre><code>git clone https://github.com/GhrammR/the-janitor\ncd the-janitor\njust build\n# Binary at: target/release/janitor\n</code></pre> <p>Or with audit verification:</p> <pre><code>just audit   # fmt + clippy + check + 103 tests\njust build\n</code></pre>"},{"location":"#pre-built-binary","title":"Pre-built Binary","text":"<p>Download the stripped release binary from Releases.</p> <pre><code>chmod +x janitor\nsudo mv janitor /usr/local/bin/\n</code></pre>"},{"location":"#v-commands","title":"V. COMMANDS","text":"<pre><code># Detect dead symbols (free, no token required)\njanitor scan &lt;path&gt; [--library] [--verbose]\n\n# Find structurally duplicate functions (free, report only)\njanitor dedup &lt;path&gt;\n\n# Apply Safe Proxy deduplication (token required)\njanitor dedup &lt;path&gt; --apply --token &lt;TOKEN&gt;\n\n# Shadow-simulate deletion + test, then physically purge (token required)\njanitor clean &lt;path&gt; --token &lt;TOKEN&gt;\n\n# Initialize symlink shadow tree\njanitor shadow init &lt;path&gt;\n\n# Load .janitor/symbols.rkyv and launch TUI dashboard (free)\njanitor dashboard &lt;path&gt;\n</code></pre>"},{"location":"#vi-legacy-deprecation-python-v4-is-dead","title":"VI. LEGACY DEPRECATION \u2014 PYTHON v4 IS DEAD","text":"<p>Python v4.0 through v4.2 are permanently deprecated.</p> <p>The Python implementation relied on ChromaDB semantic search, external LLM API calls, and NetworkX graphs. Every component has been replaced:</p> Python (v4) Rust (v5.4.0) NetworkX DiGraph <code>petgraph</code> directed reference graph Tree-sitter (Python binding) Tree-sitter (Rust, zero-copy mmap) ChromaDB + UniXcoder BLAKE3 alpha-normalized structural hashing LLM merge generation Deterministic Safe Proxy Pattern JSON manifests <code>rkyv</code> zero-copy binary registry SQLite cache <code>.janitor/symbols.rkyv</code> mmap <p>No migration path is provided. Purge your Python v4 source. Re-materialize in Rust.</p> <p>See Sovereignty \u2192 Token Gate for how the Ed25519 purge authorization works.</p>"},{"location":"sovereignty/tokens/","title":"Token Gate: Ed25519 Purge Authorization","text":"<p>Crate: <code>crates/vault</code> Guard: <code>vault::SigningOracle::verify_token(token: &amp;str) -&gt; bool</code></p>"},{"location":"sovereignty/tokens/#protocol","title":"Protocol","text":"<p>Destructive operations (<code>janitor clean</code>, <code>janitor dedup --apply</code>) require a valid purge token \u2014 a base64-encoded Ed25519 signature of the string <code>JANITOR_PURGE_AUTHORIZED</code>.</p> <pre><code>Token = Base64( Ed25519_Sign(SIGNING_KEY, \"JANITOR_PURGE_AUTHORIZED\") )\n</code></pre> <p>The binary embeds only the verifying key (32 bytes, <code>const VERIFYING_KEY_BYTES</code>). The signing key never leaves thejanitor.app.</p>"},{"location":"sovereignty/tokens/#verification-flow","title":"Verification Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  CLI flag   \u2502        \u2502  SigningOracle    \u2502        \u2502 VERIFYING_KEY   \u2502\n\u2502 --token T   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502  verify_token(T) \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 BYTES (binary)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502                           \u2502\n                          base64_decode(T)          VerifyingKey::\n                                \u2502                  from_bytes(...)\n                          sig_bytes [64]                    \u2502\n                                \u2502                           \u2502\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 verify(msg, sig) \u2500\u2518\n                                                \u2502\n                                        Ok \u2192 proceed\n                                        Err \u2192 ACCESS DENIED\n</code></pre> <ol> <li>Base64-decode the token \u2192 64-byte Ed25519 signature.</li> <li>Construct <code>Signature::from_bytes(&amp;sig_bytes)</code>.</li> <li>Call <code>verifying_key.verify(b\"JANITOR_PURGE_AUTHORIZED\", &amp;sig)</code>.</li> <li><code>Ok(())</code> \u2192 operation proceeds. Any error \u2192 process exits 1.</li> </ol>"},{"location":"sovereignty/tokens/#key-ceremony","title":"Key Ceremony","text":"<p>Run once per deployment to generate a production keypair:</p> <pre><code>cargo run -p mint-token -- generate\n</code></pre> <p>Output:</p> <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551       NEW KEYPAIR \u2014 NEVER COMMIT PRIVATE KEY  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nPRIVATE KEY (hex) \u2014 store at thejanitor.app only:\n  9d50025738375e05d5184a96c09f56b611ac59796df953874ae60258e83a9736\n\nPUBLIC KEY \u2014 paste into crates/vault/src/lib.rs:\n  const VERIFYING_KEY_BYTES: [u8; 32] = [\n      0x71, 0xbc, 0x61, 0xae, 0xe0, 0x6f, 0xac, 0x48,\n      0x5a, 0x97, 0xc4, 0x59, 0x3b, 0xd0, 0x2c, 0x43,\n      0x92, 0x61, 0x48, 0xe1, 0x33, 0xb7, 0xc5, 0x9e,\n      0x19, 0x3a, 0x8d, 0x32, 0x15, 0x3e, 0x88, 0xe9,\n  ];\n</code></pre> <p>Activation steps:</p> <ol> <li>Paste the <code>VERIFYING_KEY_BYTES</code> block into <code>crates/vault/src/lib.rs</code>.</li> <li>Rebuild: <code>just build</code>.</li> <li>Store the private key hex securely \u2014 it is never embedded in the binary.</li> </ol>"},{"location":"sovereignty/tokens/#minting-a-token","title":"Minting a Token","text":"<pre><code>cargo run -p mint-token -- mint --key &lt;64-hex-char-private-key&gt;\n</code></pre> <p>Output is the Base64 token. Pass it to any destructive operation:</p> <pre><code>janitor clean /path/to/project --token \"lS8SDsLx9dTO...\"\njanitor dedup /path/to/project --apply --token \"lS8SDsLx9dTO...\"\n</code></pre> <p>Tokens are deterministic for a given keypair: signing the same message with the same key always produces the same signature. Rotate keys to invalidate all previously issued tokens.</p>"},{"location":"sovereignty/tokens/#security-properties","title":"Security Properties","text":"Property Guarantee Unforgeability Ed25519 \u2014 128-bit security level. Signature invalid without the private key. Message binding Token is a signature of the exact string <code>JANITOR_PURGE_AUTHORIZED</code>. A token issued for any other message is rejected. Key isolation Binary embeds only the 32-byte verifying key. Private key is never present on the end-user machine. No network call Verification is fully offline \u2014 <code>VerifyingKey::verify()</code> is a pure local computation."},{"location":"sovereignty/tokens/#fallback-demo-mode","title":"Fallback / Demo Mode","text":"<p>When <code>VERIFYING_KEY_BYTES</code> is all-zeros (the placeholder default), the vault derives a fallback verifying key from <code>SIGNING_KEY_SEED</code> for test and development purposes.</p> <p>This mode is never acceptable in production. A binary with <code>VERIFYING_KEY_BYTES = [0u8; 32]</code> accepts tokens signed by the demo seed, which is public. Replace the bytes before shipping any release binary.</p>"},{"location":"sovereignty/tokens/#access-denied","title":"Access Denied","text":"<p>On an invalid or missing token, the CLI prints:</p> <pre><code>ACCESS DENIED. Purchase PQC/Ed25519 Token at thejanitor.app\n</code></pre> <p>and exits with code <code>1</code>. No partial work is performed.</p>"}]}