{
  "critique": {
    "depth_analysis": "Your current dataset is 'Syntactically Shallow'. It relies heavily on lexical token matching (Exact/Suffix) which causes two fatal flaws for a paid product: False Positives (flagging code as dead when it is used implicitly via string references) and False Negatives (keeping code that looks like a framework entry point but is actually orphaned).",
    "architectural_verdict": "As a JetBrains Architect, I would classify this as a 'Linter Configuration' rather than a 'Wisdom Pack'. Modern IDEs (PyCharm/IntelliJ) already index these symbols. To charge $49, you must move beyond AST (Abstract Syntax Tree) matching to Symbol Resolution and Control Flow Analysis. You are currently catching definitions, but missing references that occur inside configuration dicts, database rows, or meta-programming constructs."
  },
  "missing_high_value_rules": [
    {
      "framework": "SQLAlchemy",
      "edge_case": "Abstract Concrete Bases & String-based Back-references",
      "description": "Your rules miss `__abstract__ = True` in mixins. If a user deletes a Mixin because it is never instantiated directly, all inheriting models break. Furthermore, `relationship(..., back_populates='user')` uses a string to define a property on the related model. A simple deletion tool will see the 'user' attribute on the other model as unused and delete it, causing an AttributeError at runtime.",
      "complexity": "High"
    },
    {
      "framework": "Celery",
      "edge_case": "Cross-Service 'send_task' Invocations",
      "description": "Enterprise Celery setups often invoke tasks via string names from completely different microservices using `app.send_task('my.module.task_name')`. Your current rules only look for local decorators. A paid tool must allow a 'Allowlist by String Literal' to scan the codebase for strings that match task names, preventing the deletion of tasks triggered remotely.",
      "complexity": "High"
    },
    {
      "framework": "Pydantic v2",
      "edge_case": "Dynamic Alias Generators & 'model_construct'",
      "description": "Pydantic v2 allows `alias_generator` in `ConfigDict` to convert snake_case fields to camelCase for JSON APIs automatically. Your tool might delete the pythonic snake_case field because the incoming JSON keys (camelCase) never match the code variable names textually. Additionally, `model_construct` bypasses validation; fields used only there might appear dead to static analysis.",
      "complexity": "Medium"
    },
    {
      "framework": "FastAPI",
      "edge_case": "Dependency Injection via 'Depends' & Security Scopes",
      "description": "FastAPI's `Depends(get_current_user)` treats the function `get_current_user` as a dependency graph node. It is never called explicitly in code. Furthermore, Security Scopes defined in `Security(..., scopes=['read:items'])` map string literals to logic. Deleting a scope handler because it has 0 references will break the API authentication layer.",
      "complexity": "Medium"
    },
    {
      "framework": "Django",
      "edge_case": "GenericForeignKeys & ContentTypes",
      "description": "Django's `GenericForeignKey` links models based on database content (ContentType ID), not code relationships. A model might only be referenced dynamically via a GFK in a different app. If you delete a Model class because 'find usages' returns 0, you corrupt the database integrity for any row referencing that model's ContentType.",
      "complexity": "Critical"
    }
  ],
  "justification_for_price": {
    "strategy": "Transform 'Rules' into 'Safety Guarantees'",
    "contextual_safeguards": [
      {
        "feature": "String-to-Symbol Heuristics",
        "value_prop": "The tool parses string literals in the codebase (e.g., inside `ForeignKey('app.Model')`) and resolves them as valid usage references, preventing the deletion of lazily loaded components."
      },
      {
        "feature": "Implicit Lifecycle Protection",
        "value_prop": "Instead of just checking if a function is called, the tool maps the framework lifecycle. E.g., protecting `__post_init__` in dataclasses or `ready()` in Django Apps not because they are called, but because the class signature inherits from a specific framework base."
      },
      {
        "feature": "Configuration Mapping",
        "value_prop": "Scans non-Python files (YAML for Airflow, JSON for Chalice) to find entry points. Users pay $49 to ensure that deleting a Python function doesn't break a Serverless deployment defined in `serverless.yml`."
      }
    ],
    "marketing_pitch": "You aren't selling a list of regexes; you are selling 'Refactoring Insurance'. The $49 is justified if the tool can demonstrate it understands *why* code exists, not just *that* it exists."
  }
}