{
  "critique": {
    "depth_analysis": "The current dataset is dangerously shallow. It relies entirely on 'Lexical Matching' (regex/string containment) rather than 'Semantic Analysis' (AST/Symbol Resolution). In an enterprise context, this approach has a high False Negative rate. For example, a function named 'save' is protected regardless of whether it belongs to a Django Model or a random utility class, causing 'noise'. Conversely, it fails to protect code that is semantically necessary but syntactically obscure (e.g., implicit interfaces, string-based references in configs, or metaprogramming).",
    "market_viability": "At $49, developers expect intelligence that exceeds simple regex. You are currently selling a 'fancy grep' list. To justify the price, the rules must understand inheritance trees, decorator side-effects, and framework lifecycle hooks."
  },
  "missing_high_value_rules": [
    {
      "framework": "SQLAlchemy",
      "rule_type": "Metaprogramming Safeguard",
      "edge_case": "Abstract Concrete Classes & Mixins",
      "description": "Classes marked with `__abstract__ = True` or `__declared_attr__` inside Mixins often appear unused because they are never instantiated directly. However, deleting them breaks the schema generation for all inheriting models.",
      "technical_gap": "The current rules miss methods decorated with `@declared_attr` which dynamically generate columns or table args."
    },
    {
      "framework": "PySide6/PyQt6",
      "rule_type": "Reflection Safeguard",
      "edge_case": "QMetaObject Auto-Connection",
      "description": "Qt supports 'connectSlotsByName', where a function named `on_<object_name>_<signal_name>` is implicitly bound to a UI element at runtime. These functions have zero static references in the code but deleting them breaks the UI logic.",
      "technical_gap": "Current rules protect standard events (e.g., `paintEvent`) but miss specific auto-connected slots defined in .ui XML files."
    },
    {
      "framework": "FastAPI",
      "rule_type": "Type Hint Analysis",
      "edge_case": "Annotated Dependency Injection",
      "description": "In FastAPI (PEP 593), dependencies are often injected via `x: Annotated[str, Depends(get_token)]`. The function `get_token` is only referenced inside a type hint, which simple usages finders often ignore as non-executable code.",
      "technical_gap": "Need to parse AST for `Annotated` args and `Depends` calls to protect the dependency chain."
    },
    {
      "framework": "Celery",
      "rule_type": "Distributed Systems Safeguard",
      "edge_case": "Signature Primitives (Canvas)",
      "description": "Tasks are often referenced by string signatures for workflows (e.g., `signature('tasks.process_data').delay()`) or within 'Chord/Chain' primitives. Static analysis often flags `process_data` as unused if it's in a different module than the worker entry point.",
      "technical_gap": "Missing logic to resolve string literals inside `signature()`, `s()`, and `si()` calls back to the function definition."
    },
    {
      "framework": "Django",
      "rule_type": "Configuration Coupling",
      "edge_case": "Generic Foreign Keys & ContentTypes",
      "description": "The ContentType framework allows linking models without hard imports using `app_label` and `model` strings. Deleting a model that is only referenced via a GenericRelation breaks data integrity for coupled apps.",
      "technical_gap": "Rules must map `GenericForeignKey` definitions to the implicit dependencies between disparate apps."
    }
  ],
  "justification_for_price": {
    "strategy": "Contextual Safeguards",
    "sales_pitch": "Don't sell a blacklist; sell 'Architectural Empathy'. The $49 value proposition is strictly: 'We prevent the runtime crashes that static linters miss.'",
    "transformation_plan": [
      "Upgrade from 'Name Matching' to 'Inheritance Awareness' (e.g., 'Only protect `save` if class inherits `models.Model`').",
      "Implement 'String-to-Symbol Resolution' for frameworks that use configuration-based execution (Celery, Airflow XComs).",
      "Detect 'Implicit Lifecycles' (e.g., FastAPI lifespan handlers or PySide signals) that look like dead code but are invoked by C++/Rust cores."
    ]
  }
}